{"version":3,"sources":["util/solidityParser.js"],"names":["_solidityParserAntlr","_interopRequireDefault","require","parse","input","parser","parseEnum","children","subNodes","members","filter","member","type","reduce","acc","index","name","myEnum","child","stateVariable","variable","variables","expression","parseFields","prefix","indexOf","_getNameValue","stateVariableDeclarations","value","result","Error","concat","getNameValue","undefined"],"mappings":"2FAAA,IAAAA,qBAAAC,uBAAAC,QAAA,kGAEA,SAASC,MAAMC,GACb,OAAOC,qBAAAA,QAAOF,MAAMC,GAGtB,SAASE,UAAUF,GAAnB,OANAD,MAAAC,GAQ6BG,SAAS,GAAGC,SAAS,GAAxCC,QACeC,OAAO,SAAAC,GAAM,MAAoB,cAAhBA,EAAOC,OAAsBC,OAAO,SAACC,EAAKH,EAAQI,GAN1F,OAOED,EAAIH,EAAOK,MAAQD,EARvBD,EAAAC,GAAeX,EAAOY,KACbX,GACR,IAKC,SAAMY,YAASR,EAAQC,GA2Bf,OA3BgCC,MAAAP,GAAoCG,SAAAG,OAAA,SAAAQ,GAAwB,MAAA,uBAAAA,EAAAN,OAAA,GAClGJ,SAAAE,OAAA,SAAAQ,GAAA,MAAA,6BAAAA,EAAAN,OAEAC,OAAA,SAAAC,EAAAK,GAHa,IAAfC,EAAAD,EAAAE,UAAA,GAOD,IAAAD,EAAAE,WAAA,OAAAR,EAED,QAASS,IAATC,GAAoC,IAARA,EAAQR,KAAAS,QAAAD,GAAA,OAAAV,EANhC,IAAAY,EAQ0C,SAAmBN,GAA9C,OAAjBA,EAAAE,WAAAV,MACMe,IAAAA,gBAA0D,MAAUf,CAAAA,KAANQ,EAAeJ,KAAAY,MAAAR,EAAnBE,WAAAM,OAAhE,IAAA,gBAEMC,MAASF,CAAAA,KAAAA,EAAAA,KAAyBC,MAAzBR,EAAiCE,WAAMH,QAC9CC,QAcA,MAAM,IAAIU,MAAJ,uBAAAC,OAAiCX,EAASE,WAAWV,QAIzCoB,CAAaZ,GAA7BJ,EA9BRU,EA8BQV,KAAMY,EA9BdF,EA8BcE,MARR,GAFJd,EAAAE,GAAQI,OAEGa,IAAPnB,EAAAc,GAAO,MAAA,IAAAE,MAAA,oCAAAC,OAAAf,EAAA,WAAAe,OAAAH,IAAA,OAAuBA,EAAAA,GAAKZ,EAAnCF,GAgBL,iBAdK,CAoBRX,MAAAA,MAnBMG,UAAAA,UACEiB,YAAAA","file":"solidityParser.js","sourcesContent":["import parser from 'solidity-parser-antlr'\n\nfunction parse(input) {\n  return parser.parse(input)\n}\n\nfunction parseEnum(input) {\n  const parsed = parse(input)\n  const { members } = parsed.children[0].subNodes[0]\n  const myEnum = members.filter(member => member.type === 'EnumValue').reduce((acc, member, index) => {\n    acc[member.name] = index\n    acc[index] = member.name\n    return acc\n  }, {})\n\n  return myEnum\n}\n\nfunction parseFields(input, prefix) {\n  const graph = parse(input)\n  const contract = graph.children.filter(child => child.type === 'ContractDefinition')[0]\n  const stateVariableDeclarations = contract.subNodes.filter(child => child.type === 'StateVariableDeclaration')\n\n  const result = stateVariableDeclarations.reduce((acc, stateVariable) => {\n    const variable = stateVariable.variables[0]\n    // must have an assignment expression\n    if (!variable.expression) return acc\n    // check prefix if needed\n    if (prefix !== undefined && variable.name.indexOf(prefix) !== 0) return acc\n\n    // extract the name->value pair\n    function getNameValue(variable) {\n      switch (variable.expression.type) {\n        case 'StringLiteral':\n          return { name: variable.name, value: variable.expression.value }\n        case 'NumberLiteral':\n          return { name: variable.name, value: variable.expression.number }\n        default:\n          throw new Error(`Unknown Expressions ${variable.expression.type}`)\n      }\n    }\n\n    const { name, value } = getNameValue(variable)\n    // save name -> value\n    acc[name] = value\n    // prevent duplicates\n    if (acc[value] !== undefined) throw new Error(`Duplicate expressions value. var:${name} value:${value}`)\n    // save value -> name\n    acc[value] = name\n    return acc\n  }, {})\n\n  return result\n}\n\nexport default {\n  parse,\n  parseEnum,\n  parseFields,\n}\n"]}