{"version":3,"sources":["util/oauth.util.js"],"names":["_jsonwebtoken","_interopRequireDefault","require","_simpleOauth","_unixTime","_syncRequest","_rsaPemFromModExp","OAuthUtil","oauthConfig","_classCallCheck","this","appTokenCookieName","appTokenExpirationCookieName","appTokenCookieMaxAge","refreshTokenCookieName","clientId","clientSecret","redirectUri","openIdDiscoveryUrl","logoutRedirectUri","scope","openIdConfig","jwtAlgorithm","issuer","logOutUrl","keys","tokenField","serviceUsername","servicePassword","url_split","split","parse","end_session_endpoint","jwks_uri","getBody","JSON","keyResponse","error","state","redirect_uri","oauth2","authorizationCode","authorizeURL","authCode","tokenConfig","code","getToken","result","accessTokenResponse","accessToken","create","undefined","credentials","client","id","secret","auth","tokenHost","tokenPath","token_endpoint","authorizePath","authorization_endpoint","altOAuth","simpleOauth","clientCredentials","altResult","username","password","ownerPassword","decoded","jwt","decode","complete","alg","k","kid","header","x5t","key","x5c","pemKey","concat","n","e","verify","ignoreExpiration","console","log","cookieExpiry","Date","tokenObject","token","refresh","tokenResponse","req","Error","refreshToken","expiryCookie","isTokenExpired","res","clearCookie","access_token","refresh_token","cookie","maxAge","httpOnly","verified","o","getOpenIdConfig","response"],"mappings":"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","file":"oauth.util.js","sourcesContent":["import jwt from \"jsonwebtoken\";\nimport simpleOauth from \"simple-oauth2\";\nimport unixTime from \"unix-time\";\nimport request from \"sync-request\";\nimport getPem from \"rsa-pem-from-mod-exp\";\nimport '@babel/polyfill';\n\nclass OAuthUtil {\n  constructor(oauthConfig) {\n    this.appTokenCookieName = oauthConfig.appTokenCookieName;\n    this.appTokenExpirationCookieName =\n      oauthConfig.appTokenCookieName + \"_expiry\";\n    this.appTokenCookieMaxAge = oauthConfig.appTokenCookieMaxAge;\n    this.refreshTokenCookieName = oauthConfig.appTokenCookieName + \"_refresh\";\n    this.clientId = oauthConfig.clientId;\n    this.clientSecret = oauthConfig.clientSecret;\n    this.redirectUri = oauthConfig.redirectUri;\n    this.openIdDiscoveryUrl = oauthConfig.openIdDiscoveryUrl;\n    this.logoutRedirectUri = oauthConfig.logoutRedirectUri;\n    this.scope = oauthConfig.scope || \"email openid\";\n    this.openIdConfig;\n    this.jwtAlgorithm;\n    this.issuer;\n    this.logOutUrl;\n    this.keys = [];\n    this.tokenField = oauthConfig.tokenField\n      ? oauthConfig.tokenField\n      : \"access_token\"; //could use id_token\n    this.serviceUsername = oauthConfig.serviceUsername;\n    this.servicePassword = oauthConfig.servicePassword;\n    const url_split = this.openIdDiscoveryUrl.split(\"/\");\n    this.tokenHost = url_split[0] + \"//\" + url_split[2];\n  }\n  /**\n   * This function calls openIdConfigUrl to get openIdConfig and it also fetches\n   * any public keys that maybe used to sign tokens\n   * @returns {()}\n   */\n  getOpenIdConfig() {\n    try {\n      const response = request(\"GET\", this.openIdDiscoveryUrl).getBody(\"utf8\");\n      this.openIdConfig = JSON.parse(response);\n      this.jwtAlgorithm = this.openIdConfig.id_token_signing_alg_values_supported;\n      this.issuer = this.openIdConfig.issuer;\n      this.logOutUrl = this.openIdConfig.end_session_endpoint;\n\n      if (this.openIdConfig.jwks_uri) {\n        const keyResponse = request(\"GET\", this.openIdConfig.jwks_uri).getBody(\n          \"utf8\"\n        );\n        this.keys = JSON.parse(keyResponse).keys;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * This function creates a new instance of OauthUtil and populates the relevant fields\n   * @param oauthConfig\n   * @returns o an instance of the OAuthUtil\n   */\n  static init(oauthConfig) {\n    try {\n      const o = new OAuthUtil(oauthConfig);\n      o.getOpenIdConfig();\n      // get tokenHost\n\n      const credentials = {\n        client: {\n          id: o.clientId,\n          secret: o.clientSecret\n        },\n        auth: {\n          tokenHost: o.tokenHost,\n          tokenPath: o.openIdConfig.token_endpoint,\n          authorizePath: o.openIdConfig.authorization_endpoint\n        }\n      };\n\n      o.oauth2 = simpleOauth.create(credentials);\n\n      return o;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * This function gets the sign in url for oauth\n   * @method{getSigninURL}\n   * @param {String} state\n   * @returns AuthorizationUri\n   */\n  getSigninURL(state) {\n    const authorizationUri = this.oauth2.authorizationCode.authorizeURL({\n      redirect_uri: this.redirectUri,\n      scope: this.scope,\n      state: state || \"\"\n    });\n\n    return authorizationUri;\n  }\n\n  /**\n   * This function gets the access token from the authorization code\n   * @method{getAccessTokenByAuthCode}\n   * @param {String} authCode\n   * @returns AccessTokenResponse\n   */\n  async getAccessTokenByAuthCode(authCode) {\n    const tokenConfig = {\n      code: authCode,\n      redirect_uri: this.redirectUri,\n      scope: this.scope\n    };\n\n    const result = await this.oauth2.authorizationCode.getToken(tokenConfig);\n    const accessTokenResponse = this.oauth2.accessToken.create(result);\n\n    return accessTokenResponse;\n  }\n\n  /**\n   * This function gets the access token using the client secret\n   * @method{getAccessTokenByClientSecret}\n   * @param {String} clientId\n   * @param {String} clientSecret\n   * @param {String} scope\n   * @returns AccessTokenResponse\n   */\n  async getAccessTokenByClientSecret(\n    clientId = undefined,\n    clientSecret = undefined,\n    scope = undefined\n  ) {\n    const tokenConfig = {\n      scope: scope || this.scope\n    };\n\n    let accessTokenResponse;\n    if (clientId && clientSecret) {\n      const credentials = {\n        client: {\n          id: clientId,\n          secret: clientSecret\n        },\n        auth: {\n          tokenHost: this.tokenHost,\n          tokenPath: this.openIdConfig.token_endpoint,\n          authorizePath: this.openIdConfig.authorization_endpoint\n        }\n      };\n\n      const altOAuth = simpleOauth.create(credentials);\n      const altResult = await altOAuth.clientCredentials.getToken(tokenConfig);\n      accessTokenResponse = await altOAuth.accessToken.create(altResult);\n    } else {\n      const result = await this.oauth2.clientCredentials.getToken(tokenConfig);\n      accessTokenResponse = this.oauth2.accessToken.create(result);\n    }\n    return accessTokenResponse;\n  }\n\n  /**\n   * This function gets the access token using a resource owner credential\n   * @method{getAccessTokenByResourceOwnerCredential}\n   * @param {String} username\n   * @param {String} password\n   * @param {String} scope\n   * @returns AccessTokenResponse\n   */\n  async getAccessTokenByResourceOwnerCredential(username, password, scope) {\n    const tokenConfig = {\n      username: username || this.serviceUsername,\n      password: password || this.servicePassword,\n      scope: scope || this.scope\n    };\n\n    const result = await this.oauth2.ownerPassword.getToken(tokenConfig);\n    const accessTokenResponse = this.oauth2.accessToken.create(result);\n\n    return accessTokenResponse;\n  }\n\n  /** Verify JWT signature - to verify the requests to middleware that are not forwarded to STRATO to be verified on it's side\n   * @todo To be fixed to work with all OpenID providers JWKs verification mechanisms. Currently only supports Azure, does not work with Keycloak (RS256 key can't be verified against the JWK cert provided in discovery)\n   * @method{isTokenValid}\n   * @param {String} accessToken\n   * @returns {Boolean}\n   */\n  isTokenValid(accessToken) {\n    const decoded = jwt.decode(accessToken, { complete: true });\n    // FIX ME: Very azure specific\n    switch (decoded.header.alg) {\n      case \"RS256\":\n        const key = this.keys.find(\n          k => k.kid == decoded.header.kid && k.x5t == decoded.header.x5t\n        );\n        try {\n          let pemKey = \"\";\n          // azure\n          if (key.x5c) {\n            pemKey = `-----BEGIN CERTIFICATE-----\\n${\n              key.x5c[0]\n            }\\n-----END CERTIFICATE-----`;\n          }\n          // keycloak\n          if (key.n && key.e) {\n            pemKey = getPem(key.n, key.e);\n          }\n          const verified = jwt.verify(accessToken, pemKey, {\n            ignoreExpiration: false\n          });\n          return true;\n        } catch (e) {\n          console.log(e);\n          return false;\n        }\n      case \"HS256\":\n        try {\n          const verified = jwt.verify(accessToken, this.clientSecret, {\n            ignoreExpiration: false\n          });\n          return true;\n        } catch (e) {\n          return false;\n        }\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * This functions validates token expiry without validating signature\n   * @method{isTokenExpired}\n   * @param {String} accessToken\n   * @param {Number} cookieExpiry\n   * @returns {Boolean}\n   */\n  isTokenExpired(accessToken, cookieExpiry) {\n    if (cookieExpiry) {\n      return cookieExpiry <= unixTime(new Date());\n    }\n\n    const decodedToken = jwt.decode(accessToken);\n    const expiry = decodedToken[\"exp\"];\n    return expiry <= unixTime(new Date());\n    // FIX ME: Evaluate time zone issues\n  }\n\n  /**\n   * Refresh an access token, given a token object\n   * @method{refreshToken}\n   * @param tokenObject\n   * @returns Token response with updated token\n   */\n  async refreshToken(tokenObject) {\n    const token = this.oauth2.accessToken.create(tokenObject);\n    const tokenResponse = await token.refresh();\n    return tokenResponse;\n  }\n\n  /**\n   * Validate the express.js API request against the tokens validity, refresh access token seamlessly for user if needed\n   * @param req\n   * @param res\n   * @returns {Promise<*>}\n   */\n  async validateAndGetNewToken(req, res) {\n    try {\n      const accessToken = req[\"cookies\"][this.appTokenCookieName]\n        ? req[\"cookies\"][this.appTokenCookieName]\n        : null;\n      if (!accessToken) throw new Error(\"Access Token not found\");\n\n      const refreshToken = req[\"cookies\"][this.refreshTokenCookieName]\n        ? req[\"cookies\"][this.refreshTokenCookieName]\n        : null;\n      const expiryCookie = req[\"cookies\"][this.appTokenExpirationCookieName]\n        ? req[\"cookies\"][this.appTokenExpirationCookieName]\n        : null;\n\n      const expired = this.isTokenExpired(accessToken, expiryCookie);\n\n      if (!expired) {\n        return;\n      }\n\n      if (!refreshToken) {\n        res.clearCookie(this.appTokenCookieName);\n        res.clearCookie(this.appTokenExpirationCookieName);\n        throw new Error(\"Refresh Token not found\");\n      }\n\n      const tokenObject = {\n        access_token: accessToken,\n        refresh_token: refreshToken\n      };\n\n      const tokenResponse = await this.refreshToken(tokenObject);\n      // signature validation is done on STRATO node side by nginx\n      const decoded = jwt.decode(tokenResponse.token[this.tokenField]);\n\n      req[\"cookies\"][this.appTokenCookieName] =\n        tokenResponse.token[this.tokenField];\n      req[\"cookies\"][this.appTokenExpirationCookieName] = decoded[\"exp\"];\n      req[\"cookies\"][this.refreshTokenCookieName] =\n        tokenResponse.token[\"refresh_token\"];\n      res.cookie(\n        this.appTokenCookieName,\n        tokenResponse.token[this.tokenField],\n        {\n          maxAge: this.appTokenCookieMaxAge,\n          httpOnly: true\n        }\n      );\n      res.cookie(this.appTokenExpirationCookieName, decoded[\"exp\"], {\n        maxAge: this.appTokenCookieMaxAge,\n        httpOnly: true\n      });\n      res.cookie(\n        this.refreshTokenCookieName,\n        tokenResponse.token[\"refresh_token\"],\n        {\n          maxAge: this.appTokenCookieMaxAge,\n          httpOnly: true\n        }\n      );\n\n      return;\n    } catch (error) {\n      // FIXME: decide error model here\n      throw error;\n    }\n  }\n\n  /**\n   * This function constructs a logout url for oauth\n   * @method{getLogOutUrl}\n   * @returns(String) logout url\n   */\n  getLogOutUrl() {\n    return `${this.logOutUrl}?client_id=${this.clientId}&post_logout_redirect_uri=${this.logoutRedirectUri}`;\n  }\n\n  /**\n   * Get the name of the cookie storing access token\n   * @returns(String) access token cookie name\n   */\n  getCookieNameAccessToken() {\n    return this.appTokenCookieName;\n  }\n\n  /**\n   * Get the name of the cookie storing access token expire date\n   * @returns(String) access token expire date cookie name\n   */\n  getCookieNameAccessTokenExpiry() {\n    return this.appTokenExpirationCookieName;\n  }\n\n  /**\n   * Get the name of the cookie storing refresh token\n   * @returns(String) refresh token cookie name\n   */\n  getCookieNameRefreshToken() {\n    return this.refreshTokenCookieName;\n  }\n}\n\nexport default OAuthUtil;\n"]}