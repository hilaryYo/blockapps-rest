{"version":3,"sources":["util/importer.js"],"names":["_fs","_interopRequireDefault","require","_path","cwd","nodepath","resolve","process","nameStore","getImportsTree","fullname","importFullnames","isImported","array","fs","readFileSync","toString","split","parentPath","splitPath","i","length","line","startsWith","importName","getImportName","sep","importFullname","push","concat","readFileLines","buffer","slice","importFile","replace","indexOf","join","name","combine","pop","reject","filename"],"mappings":"2FAAA,IAAAA,IAAAC,uBAAAC,QAAA,OACAC,MAAAF,uBAAAC,QAAA,iFACA,IAAME,IAAMC,MAAAA,QAASC,QAAQC,QAAQH,OAEjCI,UAAY,GAEhB,SAASC,eAAeC,GAEtB,IAAIC,EAAkB,GAPxBC,WAAAF,GAWE,IAFA,IAAIG,EAAQC,IAAAA,QAAGC,aAAaL,GAAUM,WAAWC,MAAM,MACnDC,EAAaC,UAAUT,GAClBU,EAAI,EAAGA,EAAIP,EAAMQ,OAAQD,IAAK,CAVnChB,IAAGkB,EAAGjB,EAAAA,GAYR,GAAIiB,EAAKC,WAAW,UAAW,CAE7B,IAAIC,EAAaC,cAAcH,GAV5Bb,EAAeC,EAAUL,MAAAA,QAAAqB,IAAAF,EAE5Bb,GAAAA,WAAegB,GAAnB,SACAf,EAAAgB,KAAAD,GAYIhB,EAAkBA,EAAgBkB,OAAOpB,eAAekB,KAV5D,OAAIT,EAKA,SAAAO,cAAiBA,GAGjB,OAFIE,EAAcV,MAAGC,KAAAA,OAAab,GAAAA,GAAAA,GAYxC,SAAAyB,cAAApB,GACA,IAAAqB,EAAA,GAeEnB,WAAWF,GAbX,IADF,IAAAG,EAASY,IAAAA,QAAAA,aAAoBf,GAAAM,WAAAC,MAAA,MACvBO,EAAAA,EAAUJ,EAAGE,EAAKL,OAAWe,IAAM,CAiBrC,IAAIV,EAAOT,EAAMO,GAfnBE,EAAOE,WAAP,UAGFO,GAAAE,WAAAvB,EAAAY,GAAA,KAGAS,IADAT,EAAAA,EAAAY,QAAA,KAAA,MACA,KAGA,OAASJ,EAOL,SAAIR,WAAKC,EAAWD,GAClBS,IAAAA,EAAM,KAAIE,EAAWvB,KADvBc,EAEOF,EAAAY,QAAA,eAAA,IAAAA,QAAA,OAAA,IAAAA,QAAA,IAAA,IAmBT,GAAItB,WAlBAU,EAAOA,EAAaY,QAAM,KAAM,KAEjC,OADCH,GAAM,cAsBV,GAA+B,GAA3BP,EAAWW,QAAQ,KAlBvB,OAAOJ,EAAPD,cAAAzB,MAAAA,QAAA+B,KAAAhC,IAAAoB,IAIF,IAAAN,EAAAC,UAAAT,GACA,OAAAqB,EAAAD,cAAAzB,MAAAA,QAAA+B,KAAAlB,EAAAM,IAME,SAAIA,WAAaF,GACjBE,IAAAA,EAAUd,EAAGc,MAAWU,MAAAA,QAAXR,KACTd,GAmBJC,EAAQA,EAAMQ,QAAU,EAAIX,EAASO,MAAM,KAAOJ,GAnBnCW,MACbO,OAAA,EAAAA,UAAUI,QAAAE,KAuBZ7B,UAAUoB,KAAKS,IACR,GAXT,SAAAlB,UAAAT,GACA,IAAAG,EAAAH,EAAAO,MAAAZ,MAAAA,QAAAqB,KAuBE,OAtBFb,EAAAA,EAAAQ,QAAA,EAAAX,EAAAO,MAAA,KAAAJ,GAqBmBmB,MAAM,EAAGnB,EAAMQ,OAAS,GAAGe,KAAK/B,MAAAA,QAASqB,KAlB1Db,SAAKyB,QAASjB,GACd,OAsBAb,UAAY,GAtBR6B,IAAOxB,QAAM0B,SAAjBjC,EAAAkC,GACAlC,EAuBiBwB,cAAcW,mBApBrBb,CACVU,QAAAA","file":"importer.js","sourcesContent":["import fs from 'fs'\nimport nodepath from 'path'\nconst cwd = nodepath.resolve(process.cwd());\n\nlet nameStore = [];\n\nfunction getImportsTree(fullname) {\n  // console.log('getImportsTree', fullname);\n  let importFullnames = [];\n  isImported(fullname);\n  let array = fs.readFileSync(fullname).toString().split('\\n');\n  let parentPath = splitPath(fullname);\n  for (let i = 0; i < array.length; i++) {\n    let line = array[i];\n    if (line.startsWith('import')) {\n      // console.log('getImportsTree', 'line', line);\n      let importName = getImportName(line);\n      let importFullname = parentPath + nodepath.sep + importName;\n      // console.log('getImportsTree', 'importFullname', importFullname);\n      if (isImported(importFullname)) continue;\n      importFullnames.push(importFullname);\n      importFullnames = importFullnames.concat(getImportsTree(importFullname));\n    }\n  }\n  return importFullnames;\n}\n\n// supported formats:\n// import * as symbolName from \"filename\";\n// import {symbol1 as alias, symbol2} from \"filename\";\n// import \"filename\";\nfunction getImportName(line) {\n  let importName = line.split('\"').slice(-2, -1)[0];\n  // console.log('importName', importName);\n  return importName;\n}\n\n//\n//readFileLines() reads a root file and parse all imports recursively\n//\n//@param {String} fullname\n//\n\nfunction readFileLines(fullname) {\n  let buffer = '';\n  isImported(fullname);\n  //buffer += '// --- start: ' + fullname + '\\n';\n  let array = fs.readFileSync(fullname).toString().split('\\n');\n  for (let i = 0; i < array.length; i++) {\n    let line = array[i];\n    if (line.startsWith('import')) {\n      buffer += importFile(fullname, line) + '\\n';\n    } else {\n      line = line.replace('\\r', ' '); // Windows fix\n      buffer += line + '\\n';\n    }\n  }\n  //buffer += '// --- end: ' + fullname + '\\n';\n  return buffer;\n}\n\n//\n//  importFile() reconstruct the import file path, and read it, unless it was already imported\n//\n//  @param {String} fullname\n//  @param {String} line - the import line command\n// /\nfunction importFile(fullname, line) {\n  let buffer = '//' + line + '\\n';\n  let importName = line.replace(/import[\\s]+/i, '').replace(/\\\"/gi, '').replace(';', '');\n  importName = importName.replace('\\r', '');  // Windows fix\n  if (isImported(importName)) {\n    buffer += '// exists\\n';\n    return buffer;\n  }\n  // if import name starts with '/' - read relative to project root -LS\n  if (importName.indexOf('/') == 0) {\n    return buffer + readFileLines(nodepath.join(cwd, importName));\n  }\n  let parentPath = splitPath(fullname);\n  return buffer + readFileLines(nodepath.join(parentPath, importName));\n}\n\n// isImported() checks if a file is already imported\n//\n// @param {String} fullname\n// @returns {Boolean} isImported\n//\nfunction isImported(fullname) {\n  let array = fullname.split(nodepath.sep);\n  array = array.length <= 1 ? fullname.split('/') : array; // Windows fix\n  let name = array.pop();\n  if (nameStore.indexOf(name) > -1) {\n    return true;\n  }\n  nameStore.push(name);\n  return false;\n}\n\n///\n// splitPath() get the path part of a full name\n//\n// @param {String} fullname\n// @returns {Boolean} isImported\n//\nfunction splitPath(fullname) {\n  let array = fullname.split(nodepath.sep);\n  array = array.length <= 1 ? fullname.split('/') : array; // Windows fix\n  let path = array.slice(0, array.length - 1).join(nodepath.sep);\n  return path;\n}\n\nfunction combine(filename) {\n  nameStore = [];\n  return new Promise(function(resolve, reject) {\n    const string = readFileLines(filename);\n    resolve(string);\n  });\n}\n\nexport default {\n  combine,\n}\n"]}